(load "util.lisp")

(let* ((input  (map 'list #'(lambda (x)
			      (case x (#\> 1) (#\< -1)))
		    (parse "data/17.txt")))
       (wind   (make-array (length input) :initial-contents input))
       (wn     (length wind))
       (wi     (- wn 1))
       (shapes '(((0 0) (0 1) (0 2) (0 3))
		 ((0 1) (1 0) (1 1) (1 2) (2 1))
		 ((0 2) (1 2) (2 0) (2 1) (2 2))
		 ((0 0) (1 0) (2 0) (3 0))
		 ((0 0) (0 1) (1 0) (1 1))))
       (sn     (length shapes))
       (si     (- sn 1)))
  (defun next-wind ()
    (incf wi)
    (aref wind (mod wi wn)))
  (defun next-shape ()
    (incf si)
    (nth (mod si sn) shapes))
  (defun cur-shape () (mod si sn))
  (defun cur-wind () (mod wi wn)))

(defparameter *grid* (make-array '(4000 7) :initial-element 0))
(defparameter *mx* (first (array-dimensions *grid*)))
(defparameter *rr* (first (array-dimensions *grid*)))
(defparameter *cache* (make-hash-table :test 'equal))
(defparameter *last5* (make-list 5 :initial-element nil))
(defparameter *cycle* nil)

(defun shift (shape dir)
  "Shift piece in direction DIR if possible. If possible, return new coords
and t, otherwise old coords and nil."
  (let* ((dr (if (zerop dir) 1 0))
	 (dc dir)
	 (new-shape (mapcar #'(lambda (x)
				(list (+ dr (first x)) (+ dc (second x))))
			    shape)))
    (if (or (some #'(lambda (x)
		      (or (not (<= 0 (second x) 6))
			  (>= (first x) *rr*)))
		  new-shape)
	    (some #'(lambda (x)
		      (= 1 (aref *grid* (first x) (second x))))
		  new-shape))
	(values shape nil)
	(values new-shape t))))

(defun pos (shape r &optional (c 2))
  "Get starting coordinates for shape."
  (mapcar #'(lambda (x) (mapcar #'+ x (list r c))) shape))

(defun drop (shape i)
  "Drop a shape and let it fall until it rests."
  (let* ((r     (- *mx* 4))
	 (shape (pos shape (- r (- (apply #'max (mapcar #'car shape))
				   (apply #'min (mapcar #'car shape)))))))
    (while t
      (setf shape (shift shape (next-wind)))
      (multiple-value-bind (newshape res) (shift shape 0)
	(if res
	    (setf shape newshape)
	    (progn
	      (dolist (z shape)
		(setf (aref *grid* (first z) (second z)) 1))
	      (setf *last5* (butlast *last5*))
	      (push (mapcar #'second shape) *last5*)
	      (when-bind (val (gethash (apply #'append *last5*) *cache*))
		(when (equal (list (cur-shape) (cur-wind))
			     (subseq val 0 2))
		  (setf *cycle* (list (list (third val) (fourth val))
				      (list *mx* i)))
		  (return-from drop)))
	      (setf (gethash (apply #'append *last5*) *cache*)
		    (list (cur-shape) (cur-wind) *mx* i))
	      (setf *mx* (min *mx* (apply #'min (mapcar #'car shape))))
	      (return-from drop)))))))

(dotimes (i 3022 (- *rr* *mx*))
  (drop (next-shape) i)
  (when *cycle* (return)))

;; (let* ((start (first (first cycle)))
;;        (end (first (second cycle)))
;;        (height (- end start))))

(print *cycle*)
